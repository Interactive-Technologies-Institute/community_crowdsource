/* AUTH & USERS */
-- User roles & permissions
create type public.user_permission as enum (
	'users.moderate',
	'howtos.create',
	'howtos.update',
	'howtos.delete',
	'howtos.moderate',
	'events.create',
	'events.update',
	'events.delete',
	'events.moderate',
	'map.create',
	'map.update',
	'map.delete',
	'map.moderate',
	'features.update',
	'branding.update',
	'user_types.update',
	'signs.create',
	'signs.update',
	'signs.delete'
);
create type public.user_role as enum ('user', 'moderator', 'admin');
create table public.user_roles (
	id uuid primary key references auth.users on delete cascade not null,
	role user_role not null,
	unique (id)
);
create table public.role_permissions (
	id bigint generated by default as identity primary key,
	role user_role not null,
	permission user_permission not null,
	unique (role, permission)
);
create or replace function public.custom_access_token_hook(event jsonb) returns jsonb language plpgsql stable as $$
declare claims jsonb;
user_role public.user_role;
begin -- Check if the user is marked as admin in the profiles table
select role into user_role
from public.user_roles
where id = (event->>'user_id')::uuid;
claims := event->'claims';
if user_role is not null then -- Set the claim
claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
else claims := jsonb_set(claims, '{user_role}', 'null');
end if;
-- Update the 'claims' object in the original event
event := jsonb_set(event, '{claims}', claims);
-- Return the modified or original event
return event;
end;
$$;
grant usage on schema public to supabase_auth_admin;
grant execute on function public.custom_access_token_hook to supabase_auth_admin;
revoke execute on function public.custom_access_token_hook
from authenticated,
	anon;
grant all on table public.user_roles to supabase_auth_admin;
create policy "Allow auth admin to read user roles" ON public.user_roles as permissive for
select to supabase_auth_admin using (true);
create or replace function public.authorize(requested_permission user_permission) returns boolean as $$
declare bind_permissions int;
user_role public.user_role;
begin -- Fetch user role once and store it to reduce number of calls
select (auth.jwt()->>'user_role')::public.user_role into user_role;
select count(*) into bind_permissions
from public.role_permissions
where role_permissions.permission = requested_permission
	and role_permissions.role = user_role;
return bind_permissions > 0;
end;
$$ language plpgsql stable security definer
set search_path = '';
-- User profiles
create table public.profiles (
	id uuid primary key references auth.users on delete cascade not null,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
	email text not null,
	type text not null,
	display_name text not null default 'Display Name',
	description text not null default '',
	unique (id)
);
create view public.profiles_view with (security_invoker = on) as
select p.*,
	roles.role
from public.profiles p
	left join public.user_roles roles on p.id = roles.id;
create function public.handle_new_user() returns trigger language plpgsql security definer
set search_path = public as $$ begin
insert into public.user_roles (id, role)
values (new.id, 'user');
insert into public.profiles (id, email, type, display_name)
values (
		new.id,
		new.email,
		(
			select slug
			from public.user_types
			where is_default = true
		),
		new.raw_user_meta_data->>'display_name'
	);
return new;
end;
$$;
create trigger on_auth_user_created
after
insert on auth.users for each row execute procedure public.handle_new_user();
create trigger handle_updated_at before
update on public.profiles for each row execute procedure moddatetime (updated_at);
-- Storage Buckets
-- insert into storage.buckets (id, name, public, allowed_mime_types)
-- values ('users', 'Users', true, '{"image/*"}');
-- RLS policies
alter table public.user_roles enable row level security;
alter table public.role_permissions enable row level security;
alter table public.profiles enable row level security;
create policy "Allow all users to read all user roles" on public.user_roles for
select using (true);
create policy "Allow moderators to update user roles" on public.user_roles for
update using (
		auth.uid() = id
		and role = 'moderator'
	);
create policy "Allow all users to read all profiles" on public.profiles for
select using (true);
create policy "Allow users to update their own profiles" on public.profiles for
update using (auth.uid() = id);
create policy "Allow users to upload their image" on storage.objects for
insert to authenticated with check (
		bucket_id = 'users'
		and storage.filename(name) = (
			select auth.uid()::text
		)
	);
-- Seed data
insert into public.role_permissions (role, permission)
values ('user', 'howtos.create'),
	('user', 'howtos.update'),
	('user', 'howtos.delete'),
	('user', 'events.create'),
	('user', 'events.update'),
	('user', 'events.delete'),
	('user', 'map.create'),
	('user', 'map.update'),
	('user', 'map.delete'),
	('user', 'signs.create'),
	('user', 'signs.update'),
	('user', 'signs.delete'),
	('moderator', 'howtos.create'),
	('moderator', 'howtos.update'),
	('moderator', 'howtos.delete'),
	('moderator', 'howtos.moderate'),
	('moderator', 'events.create'),
	('moderator', 'events.update'),
	('moderator', 'events.delete'),
	('moderator', 'events.moderate'),
	('moderator', 'map.create'),
	('moderator', 'map.update'),
	('moderator', 'map.delete'),
	('moderator', 'map.moderate'),
	('moderator', 'signs.create'),
	('moderator', 'signs.update'),
	('moderator', 'signs.delete'),
	('admin', 'howtos.create'),
	('admin', 'howtos.update'),
	('admin', 'howtos.delete'),
	('admin', 'howtos.moderate'),
	('admin', 'events.create'),
	('admin', 'events.update'),
	('admin', 'events.delete'),
	('admin', 'events.moderate'),
	('admin', 'map.create'),
	('admin', 'map.update'),
	('admin', 'map.delete'),
	('admin', 'map.moderate'),
	('admin', 'features.update'),
	('admin', 'branding.update'),
	('admin', 'signs.create'),
	('admin', 'signs.update'),
	('admin', 'signs.delete');